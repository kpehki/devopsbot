<details>
<summary>
1. Что такое LA? В каких единицах измеряется?
</summary>
  LA (load average) -- параметр, определяющий среднюю нагрузку на систему за период времени (1 мин, 5 минут, 15 минут). Изменяется в количестве задач на одно ядро процессора. На нагрузку системы также влияет количество задач ввода-вывода и задержка сети. Также влияние на расчета LA оказывает: 1. Технология Hyper-Threading, которая делит одно физическое ядро на 2 логических, 2. Технология Turbo Bust, которая позволяет разгонять тактовую частоту процессора и работать на частоте выше заявленной, т.е. выше номинальной частоты (время на обработку одной задачи уменьшается). 
</details>
<details>
<summary>
2. Что будет если на сервере LA = 100? 
</summary>
  Вероятно, что на сервере будет наблюдаться замедленная работа сервисов, но если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной.
</details>
<details>
<summary>
3. Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?
</summary>

  На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр *wa* в утилите *top*) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему. 
</details>
<details>
<summary>
4. Представлен вывод команды *top*. Что означает каждая запись в выводе?
   ```
   top - 21:29:24 up 14:18,  1 user,  load average: 0,78, 1,48,   1,10
   Tasks: 277 total,   3 running, 274 sleeping,   0 stopped,      0 zombie
   %Cpu(s): 12,4 us,  2,5 sy,  0,1 ni, 84,8 id,  0,1 wa,  0,0   hi,  0,1 si,  0,0 st
   KiB Mem :  7106404 total,   306972 free,  3127144 used,    3672288 buff/cache
   KiB Swap:  8191996 total,  8191996 free,        0 used.    3270520 avail Mem 
   ```

</summary>

*top* - название утилиты.

*21:29:24* - текущее время системы.

*up 14:18* - сколько часов:минут система работает с момента последнего запуска.

*1 user* - количество пользователей авторизованных в системе.

*load average: 0,78, 1,48, 1,10* - параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.

*277 total* - всего процессов в системе.

*3 running* - количество процессов в работе.

*274 sleeping* - количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала.

*0 stopped* - количество приостановленных процессов сигналом STOP или выполнением трассировки.

*0 zombie* - количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.

| Параметр | Описание |
| us (user) | Использование процессора пользовательским процессами |
| sy (system) | Использование процессора системным процессами |
| ni (nice) | Использование процессора процессами с измененным приоритетом с помощью команды nice |
| id (idle) | Простой процессора. Можно сказать, что это свободные ресурсы |
| wa (IO-wait) | Говорит о простое, связанным с вводом/выводом |
| hi (hardware interrupts) | Показывает сколько процессорного времени было потрачено на обслуживание аппаратного прерывания |
| si (software interrupts) | Показывает сколько процессорного времени было потрачено на обслуживание софтверного прерывания |
| st (stolen by the hypervisor) | Показывает сколько процессорного времени было «украдено» гипервизором |

KiB Mem - количество оперативной памяти в кибибайтах (кратно 1024):
*7106404 total* -- всего доступно оперативной памяти в системе,
*306972 free* -- свободно оперативной памяти для использования,
*3127144 used* -- использовано оперативной памяти,
*3672288 buff/cache* -- буферизовано/закешировано оперативной памяти.

*KiB Swap* - количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске:
*8191996 total* - всего выделено swap-памяти,
*8191996 free* - свободно swap-памяти
*0 used* - использовано swap-памяти,
*3270520 avail Mem* - доступно для использования swap-памяти.
</details>
<details>
<summary>
5. Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?

</summary>

  В утилите top нажать `1`, чтобы отобразить все ядра в системе.
</details>
<details>
<summary>
6. Как в утилите top в Linux посмотреть какой командой был запущен процесс?

</summary>

  В утилите top нажать `c`, чтобы отобразить команды, которыми были запущены процессы.
</details>
<details>
<summary>
7. Где хранятся имена файлов/директорий?
</summary>

 - Inodes не содержат имён файлов, только другие метаданные файла. 
 - Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.
 - Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.

Таким образом имя файла/директории хранится в информационной структуре каталов.
</details>
<details>
<summary>
8. Как удалить файл с именем `-rf`?

</summary>

```
rm ./-rf
```
</details>
<details>
<summary>
9. Как посмотреть описание дискриптора? Как посмотреть время последней модификации файла?

</summary>

Посмотреть полную информацию по дискриптору возможно командой `stat <path_to_file>`.
Время модификации:
```
stat --format=%y dira
```
</details>
<details>
<summary>
10. Для чего нужна переменная окружения PATH?

</summary>

Переменная окружения PATH содержит абсолютные пути директорий, в которых производится поиск исполняемых файлов при вводе команд
</details>
<details>
<summary>
11. Как посмотреть нагрузку на диски?
</summary>
Установить утилиту `sysstat`, проверить нагрузку на диски `iostat -xtc`.
</details>
<details>
<summary>
12. Что такое файл в понятиях Unix-like операцинных системах?
</summary>

Файлы - это объекты, в которые мы записываем информацию и наши данные, исполняемые файлы, но кроме этих привычных нам понятий здесь есть файлы специального назначения - файлы устройств, файлы туннелей, сокетов и многое другое.

Типы файлов в Linux:
- Обычные файлы, для хранения информации;
- Специальные файлы - для устройств и туннелей;
- Директории.
</details>
<details>
<summary>
13. Что такое RAID? Какие массивы бывают?
</summary>

RAID (Redundant Array of Independent Disks) - избыточный массив независимых дисков, технология виртуализации данных для объединения нескольких физических дисковых устройств в логический модуль для повышения отказоустойчивости и производительности.

В зависимости от количества дисков и класса отказоустойчивости существуют следующие основные типы RAID:
RAID 0:
RAID 1:
RAID 5:
RAID 6:
RAID 10:
</details>
<details>
<summary>
14. При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?
</summary>
2 диска.
</details>
<details>
<summary>
15. В чем разница между объявлением переменной `export VAR="VALUE"` и `VAR="VALUE"` в bash?
</summary>
При объявлении переменной через export - переменная будет доступна в любых других процессах, при обычном объявлении переменной - переменная будет доступна только в запущенном процессе.
</details>
<details>
<summary>
16. Как остановить выполнение скрипта в bash при возникновении ошибки в команде?
</summary>
Команда `set -e` завершит скрипт с ошибкой, в случае, если в нижеследующем bash коде будет обнаружена ошибка. По-умолчанию bash скрипт продолжает работу, если в ходе выполнения возникла ошибка.
</details>
<details>
<summary>
17. Что в bash скрипте означает команда `set -euo pipefail`?
</summary>
Команда `set` устанавливает аттрибуты оболочки с опеределенных опций.
Опция `-e` - означает, что скрипт будет остановлен, когда произойдет ошибка в ходе его выполнения.
Опция `-u` - означает, что скрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена.
Опция `-o pipefail` - означает, что скрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка. 
</details>
<details>
<summary>
18. Как активировать debug режим в bash?
</summary>
Команда `set -x` в начале скрипта активирует вывод в консоль debug информации.
</details>
<details>
<summary>
19. Что значит `$@` в bash?
</summary>
`$@` - все параметры переданные скрипту.
</details>
<details>
<summary>
20. Какой код сигнала будет выполнен при исполнении команды `kill <PID>`?
</summary>
Сигнал SIGTERM (код 15) - это сигнал по-умолчанию отправляемый при вызове команды kill. Это указывает процессу на завершение работы и обычно считается сигналом для использования при чистом завершении работы.
</details>
<details>
<summary>
21. Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?
</summary>
```
cmd 2>&1 >/dev/null | grep pattern
```
</details>
<details>
<summary>
22. Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?
</summary>
Команда `w` покажет список пользователей, которые вошли на сервер.
</details>
<details>
<summary>
23. Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?
</summary>
Необходимо редактировать файл `/etc/ssh/sshd_config`, отвечающий за конфигурацию сервиса ssh.
</details>
<details>
<summary>
24. В каком файле находится информация о смонтированных каталогах в файловую систсему?
</summary>
Файл `/etc/fstab` содержит информацию о смонтированных каталогах в файловую систему. 
</details>
<details>
<summary>
25. Что выведет команда `cat a` и почему?
```
mkdir /tmp/abc
cd /tmp/abc
ls >a 2>b
cat a
```
</summary>
`cat a` выведет
```
a
b
```
Обработка команды идёт справа налево. Сначала создается файл *b*, потом создается файл *a*, команда `ls` отображает список файлов в текущей директории (файлы *a* и *b* уже созданы) в одну колонну и перенаправляет стандартный поток вывода (`>`) в файл *a*, а стандартный поток ошибок `2` в файл *b*. 
</details>
<details>
<summary>
26. В bash-скрипте указан аттрибут оболочки `set -x`. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?
</summary>
1 вариант: указать `|| true` после выполнения команды с ошибкой.
```sh
<command with error> || true
```

2 вариант: до выполнения данной команды указать `set +e` для игнорирования ошибок, начиная со следующей строки и после выполнения команды указать `set -e` для завершения работы скрипта в случае ошибки, начиная со следующей строки.
```sh
set -e
<command 1>
<command 2>
set +e
<command 3 wih error>
set -e
```
</details>
<details>
<summary>
27. Что такое системный вызов, какие они бывают?
</summary>
Системный вызов - обращение программы к ядру операционной системы для выполнения какой-либо операции.

В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:
- open,
- read,
- write,
- close,
- wait,
- exec, 
- fork,
- exit,
- kill.
</details>
<details>
<summary>
28. Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?
</summary>
Сигнал - в Unix-like операционных системах - асинхронное (в случайное время) уведомление процесса для обработки какого-либо события. Один из основных способов взаимодействия между процессами.

Посылка сигналов от одного процесса к другому обычно осуществляется при помощи системного вызова *kill*. Его первый параметр – PID процесса, которому посылается сигнал; второй параметр – номер сигнала.
```
kill(1111, SIGTERM);
```

Стандарт POSIX определяет 28 сигналов. Некоторые из них:

| Сигнал | Код | Описание |
| SIGTERM | 15 | Сигнал завершения (сигнал по умолчанию для утилиты kill) |
| SIGKILL | 9 | Безусловное завершение |
| SIGSTOP | 23 | Остановка выполнения процесса |
| SIGHUP | 1 | Закрытие терминала (перечитать конфигурацию) |
| SIGINT | 2 | Сигнал прерывания (Ctrl-C) с терминала |
</details>
<details>
<summary>
29. Что такое inode? Какая информация там хранится?
</summary>
Inode (индексный дескриптор) - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера inodes уникальны на уровне раздела. Каждый раздел как собственная таблица индексов. Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное место на данном разделе.

Inodes хранит метаданные о файле, к которому он относится. Эти метаданные содержат всю информацию об указанном файле.
- Размер.
- Разрешение.
- Владелец/группа.
- Расположение жесткого диска.
- Дата/время.
- Любая другая необходимая информация.
</details>
<details>
<summary>
30. Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.
</summary>
**Hard link**:
Ссылка на файл в файловой системе с использованием такого же inode идентификатора, как у файла, на который ссылаемся.
Создадим файл *realFile*.
```
touch realFile
```
Создадим hard link командой `ln <целевой_файл> <файл_ссылка>`:
```
ln realFile hardLink
```
Проверим, что inode у файла *realFile* и hard ссылке *hardLink* имеют одинаковый идентификатор.
```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
```
Как видно realFile и hardLink имеют одинаковый идентификатор inode.

**Soft link**: 
Создадим soft ссылку на файл *realFile*.
```
ln -s realFile softLink
```
Проверим, что чистовой идентификатор *softLink* отличается от числового идентификатора *realFile*.
```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
2366763 lrwxrwxrwx 1 rmntrvn rmntrvn 8 апр 25 23:29 softLink -> realFile
```

Некоторые нюансы:
- Soft ссылки используют различные номера inode, чем основные файлы.
- Soft ссылки становятся полезными, если исходный файл был удален.
- Soft ссылки могут быть созданы из каталогов.
- Soft ссылка может быть создана на пересечении файловых систем.

- Hard ссылка может размещаться только на том же логическом разделе, что и оригинальный файл. Это связано с независимой идентификацией файлов на разных разделах.
- Создание жестких ссылок не поддерживается для папок — только для файлов.
- Файловая система должна поддерживать работу с hard ссылками.
</details>
<details>
<summary>
31. Какие состояния процессов существуют? Что значит состояние процесса D?
</summary>
|                   Статус                |                Описание                 |
|             R (running or runnable)     |    Выполняется или готов к выполнению   |
|           D (uninterruptible  sleep)    |          Ожидает записи на диск         |
|             S (interruptible sleep)     |            `Неактивен (< 20 s)`           |
|        T (stopped by job control signal)|  Остановлен или трассируется отладчиком |
|                   Z (zombie)            |                  зомби                  |
| W (paging (not valid since the 2.6.xx)) |         Процесс выгружен на диск        |
|                        `>`                | Процесс имеет повышенный приоритет nice |
|                        N                | Процесс имеет пониженный приоритет nice |
|                   L (locked)            |  Некоторые страницы блокированы в ядре  |
|                        s                |     Процесс является лидеров сеанса     |
</details>
<details>
<summary>
32. Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?
</summary>
*Процесс-зомби* - дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

Удаление зомби возлагается на родительский процесс или системный вызов `wait()` также может это выполнить, поэтому перед ее вызовом не нужно проверять, продолжает ли выполняться требуемый дочерний процесс. Если родительский процесс не удалит своих потомков, то они останутся в состоянии зомби.

Убить зомби-процесс невозможно. Чтобы убить зомби-процесс нужно найти родительский процесс и завершить его или перезапустить. Найти зомби-процессы и их родителей можно следующей командой:
```
ps ajx | grep -w Z
```
PID'ы процессов родителей в 3 колонке. Убить процесс следующей командой:
```
kill -9 <PID процесса родителя>
```

*Процесс-сирота* — в семействе операционных систем UNIX вспомогательный процесс, чей основной процесс (или связь с ним) был завершен нештатно (не подав сигнала на завершение работы).

---

Отличие в том, что процесс-сирота (orphan process) всё еще активен. Его родительский процесс был по какой-либо причине прерван, и сирота теперь переходит под руководство init, чей ID процесса равен 1. PPID orphan процесса получит значение 1. Пользователь также может создать подобный процесс, отсоединив его от терминала. Сиротские процессы используют много ресурсов, их легко найти с помощью top или htop.

В отличии от процесса-сироты, зомби-процесс неактивен, но контролируется родительским процессом, пока тот не решит, что статус выхода дочерних процессов больше не нужен. Он не использует ресурсы и не может быть запланирован для выполнения. Иногда родительский процесс удерживает дочерний процесс в состоянии зомби, чтобы гарантировать, что будущие дочерние процессы не получат тот же PID. Если вы уничтожите родителя зомби-процесса, зомби-процесс тоже умрет. Для этого найдите родительский PID (PPID) зомби и отправьте ему сигнал SIGCHLD (17): kill -17 ppid.
</details>
<details>
<summary>
33. Что такое файловый дескриптор? Какая информация там хранится?
</summary>
*Файловый дескриптор* - неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор. 
</details>
<details>
<summary>
34. Что такое buffer/cache память? Для чего нужна?
</summary>
buff/cache память - рассчитанная память, которая зарезервирована, но может быть освобождена при необходимости и используется для быстрого доступа программами к данным, которые находятся в оперативной памяти (быстрой памяти).

buffers — буферы в памяти — страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого, так же известна как heap-memory;
cached — файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай если вскоре они снова потребуются.
</details>
<details>
<summary>
35. Представлен вывод команды `free`.
```
$ free -m
              total        used        free      shared  buff/cache   available
Mem:           6930        3598         843         183        2489        2919
Swap:         15999           4       15995
```
Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?
</summary>
- Total. Эта цифра представляет всю существующую память.
- Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.
```
used = total - free - buff/cache
```
- Free – свободная память в системе.
- Shared – память, используемая (преимущественно) в tmpfs
- Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
- Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки. В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент.
</details>
<details>
<summary>
36. Порядок загрузки дистрибутива Linux.
</summary>
1. Включение компьютера кнопкой.
2. Загрузить BIOS / UEFI из NVRAM.
3. Собрать сведения об аппаратуре.
4. Выбрать устройства для запуска (диск, сеть).
5. Идентифицировать системный раздел EFI.
6. Загрузить BIOS / UEFI из NVRAM.
7. Определить какое ядро загрузить.
8. Загрузить ядро.
9. Создать структуры данных ядра.
10. Запустить init / systemd как PID 1.
11. Выполнить сценарии запуска.
12. Запустить систему.
</details>
<details>
<summary>
37. Какие файловые системы есть в linux?
</summary>
журналируемые и не журналируемые (Определить тип можно при помощи команды file -s. ФС первого типа ведут логи, фиксируя в отдельном файле информацию о действиях пользователя и план проверки системы. За счёт логирования система получается более устойчивой к сбоям. ФС второго типа не имеют логов. Они обладают хорошим быстродействием, но более уязвимы, так как не обеспечивают сохранность данных.)
    Ext2; не журналируемая, часто используется на флеш-картах и твердотельных накопителях (SSD), SSD живет дольше.
    Ext3; журналируемая, совместима с Ext2, существует возможность восстановления удаленных файлов или восстановления файловой системы, макс. размер 16 ТБ, один файл 2тб.
    Ext4; основная система сейчас. журналируемая, совместима с Ext3, макс размер 1 экзБ, 1 файл 16тб. Неограниченное кол-во каталогов. Поддержка шифрования, поддержка по умолчанию во многих дистрибутивах, не подвержена фрагментации, лимитов достаточно пользователю и серверу.
    JFS; система IBM, поддерживается логирование изменений из коробки. При каждом изменении файла система записывает определенные метаданные в зарезервированную область файловой системы. Фактическая операция записи выполняется только после изменения метаданных в журнале. Устарела?
    ReiserFS; журналируемая файловая система, преимуществ перед Ext4 нет. Поддерживает конфигурируемое блочное перераспределение — возможность упаковки нескольких небольших файлов в один блок во избежание фрагментации и потери дискового пространства.
    XFS; журналируемая, изначально придумана для RAID массивов больших объемов.
    Btrfs; Btrfs — это современная файловая система для Linux, использующая принцип «копирование при записи» (CoW), направленная на реализацию дополнительных функций с особым упором на отказоустойчивость, восстановление и простоту администрирования
    ZFS лицензированный аналог Btrfs.
</details>
<details>
<summary>
38. Какие фс есть еще?
</summary>
tmpfs. Записывает данные в оперативную память, создавая блочное устройство требуемого размера, которое затем подключают к папке. 
procfs. Отвечает за хранение информации о системных процессах и ядре. 
sysfs. Управляет настройками ядра ОС.
</details>
<details>
<summary>
39. Как работает swap?
</summary>
swap - это механизм виртуальной памяти, при котором часть данных из ОЗУ перемещается на хранение на HDD/SSD. Часть перативной памяти выгружется в файл подкачки со своей ФС, освобождая место в оперативе для необходимого процесса.
</details>
<details>
<summary>
40. Почему swap - отстой?
</summary>
Если использовать его для экстренного расширения памяти - отстой, т.к. работает сильно медленнее ОЗУ и при обращении к данным в свопе работает снова через ОЗУ. Если выгрузить данные "спящих" процессов с малой нагрузкой - будет работать хорошо.
</details>
<details>
<summary>
41. Что такое LVM? 
</summary>
Это дополнительный слой абстракции от железа, позволяющий собрать кучи разнородных дисков в один, и затем снова разбить этот один именно так как нам хочется.
</details>
<details>
<summary>
42. Можно ли навалить доп постоянной памяти на виртуалку не ребутая ее?
</summary>
Можно. Кратко: надо расширить объем диска в VM, затем расширить в гостевой ОС. `sudo vgextend <PV Name>`
`sudo lvresize <LV Path> -L +<объем, который нужно добавить>`
`sudo resize2fs /dev/mapper/ubuntu—vg-ubuntu--lv `
</details>
<details>
<summary>
43. Диски в разрезе linux(как линь воспринимает диск)
</summary>
Диск воспринимается как блочное устройство. Диск лежит в /dev/sda(b)(c) и тп. Диску необходимо задать разделы, тип файловой системы и точку монтирования. посмотреть диски lsblk. список разделов fdisk -l.  
</details>
<details>
<summary>
44. Как посмотреть версию ядра linux
</summary>
Командой uname -a, либо командой hostnamectl.
</details>
<details>
<summary>
45. Как посмотреть место на диске?
</summary>
Командой df
df -h показывает дисковое пространство в удобочитаемом формате

df -a показывает полное использование диска файловой системой, даже если в поле «Available» установлено значение 0

df -i показывает используемые и свободное место
</details>
<details>
<summary>
46. Как читать логи?
</summary>
Командой tail (последние 10 строк)
Командой head (первые 10 строк) -n N (покажет N строк конца файла)
tail -f (показывает последние записи в реальном времени)
</details>
<details>
<summary>
47. Как проверить что логи пишутся?
</summary>
Командой tail -f
</details>
<details>
<summary>
48. Куда пишутся логи в Linux?
</summary>
/var/log
</details>
<details>
<summary>
49. Структура файловой системы Linux
</summary>
/ — корень

/bin — бинарные файлы пользователя

/sbin — системные исполняемые файлы

/etc - конфигурационные файлы всех программ, которые установлены в системе

/dev — файлы устройств

/proc — информация о процессах

/var — переменные файлы
• /var/log — файлы логов;
• /var/lib — базы данных;
• /var/lock — файлы блокировок;
• /var/mail — почта;
• /var/spool — принтер, печать;
• /var/run — pid процессов.

/tmp - временные файлы

/usr — программы пользователя

• /usr/bin/ — исполняемые файлы
• /usr/sbin/ — бинарные файлы программ, предназначенных для системного администрирования 
• /usr/lib/ — библиотеки для программ
• /usr/local — файлы пользователя (программы, библиотеки и настройки, созданные пользователем).

/home — домашняя папка

/boot — файлы загрузчика

/lib — системные библиотеки

/opt — дополнительные программы

/mnt — монтирование

/media — съемные носители

/srv — Файлы сервисов и серверов. Как пример — web-сервер Apache.

/run — процессы

/sys — информация о системе
</details>
<details>
<summary>
50. Как посмотреть к каким группам принадлежит user?
</summary>
id user
</details>
<details>
<summary>
51. Как посмотреть всех user системы?
</summary>
cat /etc/passwd

Пользователи с ID меньше 1000 - системные, они были созданы во время установки некоторых сервисов для более безопасной их работы.
</details>
<details>
<summary>
52. Что храниться в /etc/shadow?
</summary>
Это зашифрованный файл паролей, в котором хранится зашифрованная информация о паролях для учетных записей пользователей. В дополнение к хранению зашифрованного пароля файл /etc/shadow хранит дополнительную информацию о сроке действия или истечении срока действия пароля
</details>
<details>
<summary>
53. Отличия /etc/passwd и /etc/shadow?
</summary>
Файл /etc/passwd доступен для чтения по словам, а это означает, что любой пользователь может его прочитать, но файл /etc/shadow доступен для чтения только учетной записи root.
</details>
<details>
<summary>
54. Как проверить конфиг nginx?
</summary>
Чтобы проверить на ошибки конфиг nginx, нужно использовать опцию -t.

Опция -t заставит nginx проверить конфигурационный файл на корректный синтаксис и наличие ошибок, и затем попытается открыть файлы, указанные в конфигурации.

Для проверки конфига nginx на ошибки, используйте команду:

 nginx -c /usr/local/etc/nginx/nginx.conf -t

Опция -c /path/to/config/file указывает, какой конфигурационный файл nginx должен использовать вместо используемого по-умолчанию.
</details>

